{"meta":{"title":"Rapheal's Tech Blog","subtitle":"","description":"Raphael's Tech Blog","author":"Raphael","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Docker Spring Boot build with Dockerfile","slug":"Docker-Spring-Boot-build-with-Dockerfile","date":"2021-02-05T15:06:39.000Z","updated":"2021-02-05T16:02:19.758Z","comments":true,"path":"2021/02/05/Docker-Spring-Boot-build-with-Dockerfile/","link":"","permalink":"http://example.com/2021/02/05/Docker-Spring-Boot-build-with-Dockerfile/","excerpt":"","text":"Create a spring boot, import springframework.web package. Create a controller: package com.example.dockerspringboot.resource; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RequestMapping(“/rest/docker/hello”) @RestController public class HelloRes { @GetMapping public String hello () &#123; return &quot;hello J&quot;; &#125; } porm.xml change finalname to docker-sb.jar define server.port=8085 in application.properties create Dockerfile: FROM openjdk:11 ADD target/docker-sb.jar docker-sb.jar EXPOSE 8085 ENTRYPOINT [“java”,”-jar”,”docker-sb.jar”] create docker image : $ docker build -f Dockerfile -t rafwang/docker-sb . run in docker: $ docker run -p 8085:8085 rafwang/docker-sb visit http://localhost:8085/rest/docker/hello Study Case: docker-springboot video","categories":[],"tags":[]},{"title":"Nacos","slug":"Nacos","date":"2021-02-05T09:54:02.000Z","updated":"2021-02-05T13:37:36.176Z","comments":true,"path":"2021/02/05/Nacos/","link":"","permalink":"http://example.com/2021/02/05/Nacos/","excerpt":"","text":"Start Nacos in docker-compose : services: nacos-registry: image: nacos/nacos-server:1.3.0 container_name: nacos-registry environment: - &quot;MODE=standalone&quot; ports: - 8848:8848 $ docker-compose -f docker-compose-env.yml up -d http://{ip}:8848/nacos/index.html username: nacos password:nacos","categories":[],"tags":[]},{"title":"Docker Stack Deploy","slug":"Docker-Stack-Deploy","date":"2021-02-04T08:16:23.000Z","updated":"2021-02-04T08:21:19.998Z","comments":true,"path":"2021/02/04/Docker-Stack-Deploy/","link":"","permalink":"http://example.com/2021/02/04/Docker-Stack-Deploy/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Install Docker & Docker Commands","slug":"Docker","date":"2021-02-03T20:08:17.000Z","updated":"2021-02-04T05:37:16.881Z","comments":true,"path":"2021/02/03/Docker/","link":"","permalink":"http://example.com/2021/02/03/Docker/","excerpt":"","text":"Install Docker on the Ubuntu Desktop 20.04Here is the document from docker. First I remove the old version: $ sudo apt-get remove docker docker-engine docker.io containerd runc Then I Installed using the convenience script. Here it is: $ curl -fsSL https://get.docker.com -o get-docker.sh $ sudo sh get-docker.sh Remeber to add your accound to the docker group after the installation. $ sudo usermod -aG docker &lt;your-user&gt; And you need to check if the docker command is belong to docker group. Usually it is belong to root group. $ ls -al `which docker` If not, you need to change the group manually. $ sudo chgrp docker `which docker` To test if the installation is working correctly: $ docker run hello-world If you encounter the permission denied issue, try: $ sudo systemctl restart docker and logout. This worked for me. Basic Docker CommandsStart a container $ docker run nginx List containers ~$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8db74ee17b0d nginx &quot;/docker-entrypoint.…&quot; About a minute ago Up About a minute 80/tcp thirsty_lehmann fefbc75c1d6e hello-world &quot;/hello&quot; 8 minutes ago Exited (0) 8 minutes ago great_feynman Stop a container $ docker stop thirsty_lehmann Remove a container $ docker rm thirsty_lehmann List images $ docker images Remove images $ docker rmi nginx Download un image $ docker pull nginx Run a command in the container of ubuntu $ docker run ubuntu sleep 100 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 796ba8ba8091 ubuntu &quot;sleep 100&quot; 9 seconds ago Up 7 seconds beautiful_euclid $ docker exec beautiful_euclid cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback Detach and attach $ docker run -d nginx Docker Command line Document Docker Official Images on Docker Hub Document Docker Hub: https://hub.docker.com/ Runtag: 12345$ docker run redis:4.0$ docker run kodekloud&#x2F;simple-prompt-docker Welcome! Please enter your name: Hello and Welcome ! Stdin 1234$ docker run -i kodekloud&#x2F;simple-prompt-docker Welcome! Please enter your name: hallo-kettyHello and Welcome hallo-ketty! Terminal Mode 1$ docker run -it kodekloud&#x2F;simple-prompt-docker Port mapping 1$ docker run -p new_port:container_port kodekloud&#x2F;simple-webapp Volume mapping 12$ docker run -v new_file:container_file mysql$ docker run -v &#x2F;opt&#x2F;datadir:&#x2F;var&#x2F;lib&#x2F;mysql mysql Inspect Container 12$ docker inspect container_name$ docker inspect -f &#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; container_name logs 1$ docker logs container_name ENV variables 1$ docker run -e ENV_VAR&#x3D;env_var_value image_name Containerizing create a dockerfile docker build Dockerfile -t account_name/image_name docker push account_name/image_name dockerfile: start from a base OS or another image: FROM Ubuntu install all dependencies: RUN apt-get update RUN apt-get install python RUN pip install flask RUN pip install flask-mysql Copy source code: COPY . /opt/source-code Specify Entrypoint: ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run CMD &amp; ENTRYPOINTIn the dockerfile, the CMD instruction has three forms: CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form) CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT) CMD command param1 param2 (shell form) There can only be one CMD instruction in a Dockerfile. If you list more than one CMD then only the last CMD will take effect. ENTRYPOINT has two forms: The exec form, which is the preferred form: 1ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] The shell form: 1ENTRYPOINT command param1 param2 An ENTRYPOINT allows you to configure a container that will run as an executable. NetworkingDefault Networking: docker run ubuntu With –networking flag, None network: docker run ubuntu --networking=none Attach to the ports of the host docker run ubuntu --networking=host Choose the IP addresses for the container with –ip and –ip6 flags docker run -itd --network=my-net --ip=10.10.9.75 ubuntu Command Description docker network connect Connect a container to a network docker network create Create a network docker network disconnect Disconnect a container from a network docker network inspect Display detailed information on one or more networks docker network ls List networks docker network prune Remove all unused networks docker network rm Remove one or more networks docker network create --driver bridge --subnet 182.18.0.0\\16 [NAME] Inspect Network: docker inspect [IMAGE NAME] Embedded DNS Storage$ sudo ls /var/lib/docker/ buildkit containers image network overlay2 plugins runtimes swarm tmp trust volumesaufs Volume flag allow to persist data : docker volume create data_volume Then docker will create a directory /var/lib/docker/volumes/data_volume docker run -v data_volume:/var/lib/mysql mysql Or to bind to a local location: docker run -v /data/mysql:/var/lib/mysql mysql Or bind to a storage driver: docker run –mount type=bind,source=/data/mysql,target=/var/lib/mysql mysql Docker Compose–linkdocker run -d --name=redis redis docker run -d --name=db mysql docker run -d --name=vote -p 5000:80 --link redis:redis voting-app docker run -d --name=result -p 5001:80 --link db:db result-app docker run -d --name=worker --link db:db --link redis:redis worker To docker-compose.yml Services: redis: image: &quot;redis&quot; db: image: &quot;mysql&quot; vote: image: &quot;voting-app&quot; ports: - 5000:80 links: - redis result: image: &quot;result-app&quot; ports: - 5001:80 links: -db worker: image: &quot;worker&quot; links: - redis - db -buildServices: redis: image: &quot;redis&quot; db: image: &quot;mysql&quot; vote: build: ./voting-app ports: - 5000:80 links: - redis result: build: ./result-app ports: - 5001:80 links: -db worker: build: ./worker links: - redis - db $ docker-compose up Docker compose -version Front-end &amp; back-end network Services: redis: image: &quot;redis&quot; networks: - back-end db: image: &quot;mysql&quot; networks: - back-end vote: build: ./voting-app ports: - 5000:80 links: - redis networks: - front-end result: build: ./result-app ports: - 5001:80 links: -db networks: - front-end worker: build: ./worker links: - redis - db networks: - back-end networks: front-end: back-end: Docker Registryprivate registry: docker login private-registry.io docker run private-registry.io/app/interal-app deploy private registry: docker run -d -p 5000:5000 --name=registry registry:2 docker image tag my-image localhost:5000/my-image docker push localhost:5000/my-image docker pull localhost:5000/my-image docker pull 192.168.56.100:/my-image Engine docker run --cpus=0.5 ubuntu docker run --memory=100m ubuntu Engine Container Orchestrationdocker service create --duplicas=100 nodejs Solutions: docker swarm, kubernetes, MESOS Docker SwarmResponsible for load balancing on the docker hostsOn Swarm Manager: $ docker swarm init On swarm workers: $ docker swarm join --token &lt;token&gt; Then on the manager again: $ docker service create --replicas=3 -p 8080:80 my-web-server kubernetes$ kubectl run --replicas=1000 my-web-server $ kubectl scale --replicas=2000 my-web-server $ kubectl rolling-update my-web-server --image=web-server:2 $ kubectl rolling-update my-web-server --rollback ref VIDEO","categories":[],"tags":[]},{"title":"Deploy Hexo To Github","slug":"Deploy-Hexo-To-Github","date":"2021-01-26T17:32:16.000Z","updated":"2021-01-27T07:33:52.493Z","comments":true,"path":"2021/01/26/Deploy-Hexo-To-Github/","link":"","permalink":"http://example.com/2021/01/26/Deploy-Hexo-To-Github/","excerpt":"","text":"Recently, I am working on a mini project. It has been years that I touch no more coding. A lot of new frameworks pump me up. And I feel it is real worth to note this experience on the blog. So I am starting with deploy a blog. Voila comme ci-dessous. Local Env: Ubuntu 20.04, Thinkpad X240sStep 1. install hexo on the local machinesudo npm install -g hexo-cli cd &amp;&amp; mkdir Blog &amp;&amp; cd Blog hexo init Step 2. change themecd ~/Blog/ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia Then add theme config to _config.yml don’t foget to set theme yilia don’t foget to tab a space between colon and value don’t repeat the key theme: yilia deploy: &nbsp;&nbsp;&nbsp;&nbsp; type: git &nbsp;&nbsp;&nbsp;&nbsp; repo: https://github.com/Raphael-De-Wang/Raphael-De-Wang.github.io.git &nbsp;&nbsp;&nbsp;&nbsp; branch: master Step 3. add a posthexo n &quot;post name&quot; The new post will be created in the fold source/_posts hexo clean hexo g hexo s Start the hexo server in local, preview the post in localhost:4000 Step 4. depoly to Githubcreate a new project, pick the name same as your username, plus github.io, then push the hexo to github. hexo clean hexo g hexo d Don’t forget to set the github username and email before push","categories":[],"tags":[{"name":"Github, Hexo","slug":"Github-Hexo","permalink":"http://example.com/tags/Github-Hexo/"}]}],"categories":[],"tags":[{"name":"Github, Hexo","slug":"Github-Hexo","permalink":"http://example.com/tags/Github-Hexo/"}]}